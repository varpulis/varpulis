// VarpulisQL Grammar for LALRPOP
// 
// NOTE: This grammar is a REFERENCE DOCUMENT only.
// The actual parser is hand-written (recursive descent) in parser.rs
// This file documents the intended syntax but is NOT compiled.
// 
// Keep this in sync with ast.rs when making changes.

use std::str::FromStr;
use crate::ast::*;

grammar;

// ============================================================================
// LEXER RULES (Terminals)
// ============================================================================

match {
    // Skip whitespace and comments
    r"\s*" => { },
    r"#[^\n\r]*" => { },  // Single-line comments
    r"/\*([^*]|\*[^/])*\*/" => { },  // Multi-line comments
    
    // Keywords
    "stream" => STREAM,
    "event" => EVENT,
    "type" => TYPE,
    "let" => LET,
    "var" => VAR,
    "const" => CONST,
    "fn" => FN,
    "config" => CONFIG,
    
    "if" => IF,
    "else" => ELSE,
    "elif" => ELIF,
    "match" => MATCH,
    "for" => FOR,
    "while" => WHILE,
    "break" => BREAK,
    "continue" => CONTINUE,
    "return" => RETURN,
    
    "from" => FROM,
    "where" => WHERE,
    "select" => SELECT,
    "join" => JOIN,
    "merge" => MERGE,
    "window" => WINDOW,
    "aggregate" => AGGREGATE,
    "partition_by" => PARTITION_BY,
    "order_by" => ORDER_BY,
    "limit" => LIMIT,
    "distinct" => DISTINCT,
    "emit" => EMIT,
    "to" => TO,
    
    "pattern" => PATTERN,
    "attention_window" => ATTENTION_WINDOW,
    "attention_score" => ATTENTION_SCORE,
    
    "true" => TRUE,
    "false" => FALSE,
    "null" => NULL,
    
    "and" => AND,
    "or" => OR,
    "not" => NOT,
    "in" => IN,
    "is" => IS,
    
    "try" => TRY,
    "catch" => CATCH,
    "finally" => FINALLY,
    "raise" => RAISE,
    
    "as" => AS,
    "extends" => EXTENDS,
    "import" => IMPORT,
    "export" => EXPORT,
    
    "int" => INT_TYPE,
    "float" => FLOAT_TYPE,
    "bool" => BOOL_TYPE,
    "str" => STR_TYPE,
    "timestamp" => TIMESTAMP_TYPE,
    "duration" => DURATION_TYPE,
    "Stream" => STREAM_TYPE,
    
    // Operators
    "+" => PLUS,
    "-" => MINUS,
    "*" => STAR,
    "/" => SLASH,
    "%" => PERCENT,
    "**" => DOUBLESTAR,
    
    "==" => EQEQ,
    "!=" => NEQ,
    "<" => LT,
    "<=" => LE,
    ">" => GT,
    ">=" => GE,
    
    "&" => AMP,
    "|" => PIPE,
    "^" => CARET,
    "~" => TILDE,
    "<<" => LSHIFT,
    ">>" => RSHIFT,
    
    "=" => EQ,
    "+=" => PLUSEQ,
    "-=" => MINUSEQ,
    "*=" => STAREQ,
    "/=" => SLASHEQ,
    "%=" => PERCENTEQ,
    
    "." => DOT,
    "?." => QDOT,
    "??" => QQMARK,
    "=>" => ARROW,
    "->" => RARROW,
    ".." => DOTDOT,
    "..=" => DOTDOTEQ,
    
    "(" => LPAREN,
    ")" => RPAREN,
    "[" => LBRACKET,
    "]" => RBRACKET,
    "{" => LBRACE,
    "}" => RBRACE,
    "," => COMMA,
    ":" => COLON,
    "?" => QMARK,
    
    // Literals
    r"[0-9]+" => INTEGER,
    r"[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?" => FLOAT,
    r#""[^"]*""# => STRING,
    r"'[^']*'" => STRING_SINGLE,
    r"[0-9]+(ns|us|ms|s|m|h|d)" => DURATION,
    r"@[0-9]{4}-[0-9]{2}-[0-9]{2}(T[0-9]{2}:[0-9]{2}:[0-9]{2}(Z|[+-][0-9]{2}:[0-9]{2}))?" => TIMESTAMP,
    
    // Identifiers
    r"[a-zA-Z_][a-zA-Z0-9_]*" => IDENTIFIER,
}

// ============================================================================
// AST TYPES (defined in separate module)
// ============================================================================

// Types are defined in varpulis-core/src/ast.rs:
// 
// pub enum Stmt { StreamDecl, EventDecl, TypeDecl, VarDecl, FnDecl, ... }
// pub enum Expr { Binary, Unary, Call, Member, Lambda, Literal, ... }
// pub enum Type { Int, Float, Bool, Str, Array, Map, Optional, ... }
// pub enum StreamSource { Ident, From, Merge, Join, Sequence, ... }
// pub enum StreamOp { Where, Select, Window, FollowedBy, Within, Not, ... }
// 
// NOTE: The parser returns (StreamSource, Vec<StreamOp>) not a StreamExpr struct.

// ============================================================================
// GRAMMAR RULES
// ============================================================================

// Entry point
pub Program: Vec<Stmt> = {
    <stmts:Stmt*> => stmts,
};

// Statements
Stmt: Stmt = {
    StreamDecl,
    EventDecl,
    TypeDecl,
    VarDecl,
    FnDecl,
    ConfigBlock,
    ImportStmt,
    ExprStmt,
};

// ============================================================================
// STREAM DECLARATIONS
// ============================================================================

StreamDecl: Stmt = {
    STREAM <name:Identifier> FROM <source:Identifier> 
        => Stmt::StreamDecl { name, source: StreamSource::From(source), ops: vec![] },
    
    STREAM <name:Identifier> EQ <expr:StreamExpr>
        => Stmt::StreamDecl { name, source: expr.source, ops: expr.ops },
    
    STREAM <name:Identifier> COLON <ty:Type> EQ <expr:StreamExpr>
        => Stmt::StreamDeclTyped { name, ty, source: expr.source, ops: expr.ops },
};

StreamExpr: StreamExpr = {
    <source:StreamSource> <ops:StreamOp*> => StreamExpr { source, ops },
};

StreamSource: StreamSource = {
    <id:Identifier> => StreamSource::Ident(id),
    
    MERGE LPAREN <streams:StreamList> RPAREN 
        => StreamSource::Merge(streams),
    
    JOIN LPAREN <clauses:JoinClauseList> RPAREN
        => StreamSource::Join(clauses),
};

StreamList: Vec<StreamDecl> = {
    <first:InlineStreamDecl> <rest:(COMMA <InlineStreamDecl>)*> 
        => std::iter::once(first).chain(rest).collect(),
};

InlineStreamDecl: StreamDecl = {
    STREAM <name:Identifier> FROM <source:Identifier> <filter:(WHERE <Expr>)?>
        => StreamDecl { name, source, filter },
};

JoinClauseList: Vec<JoinClause> = {
    <first:JoinClause> <rest:(COMMA <JoinClause>)*>
        => std::iter::once(first).chain(rest).collect(),
};

JoinClause: JoinClause = {
    STREAM <name:Identifier> FROM <source:Identifier> <on:(ON <Expr>)?>
        => JoinClause { name, source, on },
};

// Stream operations
StreamOp: StreamOp = {
    DOT WHERE LPAREN <cond:Expr> RPAREN
        => StreamOp::Where(cond),
    
    DOT SELECT LPAREN <items:SelectList> RPAREN
        => StreamOp::Select(items),
    
    DOT WINDOW LPAREN <args:WindowArgs> RPAREN
        => StreamOp::Window(args),
    
    DOT AGGREGATE LPAREN <aggs:AggList> RPAREN
        => StreamOp::Aggregate(aggs),
    
    DOT PARTITION_BY LPAREN <key:Expr> RPAREN
        => StreamOp::PartitionBy(key),
    
    DOT ORDER_BY LPAREN <items:OrderList> RPAREN
        => StreamOp::OrderBy(items),
    
    DOT LIMIT LPAREN <n:Expr> RPAREN
        => StreamOp::Limit(n),
    
    DOT DISTINCT LPAREN <expr:Expr?> RPAREN
        => StreamOp::Distinct(expr),
    
    DOT "map" LPAREN <f:Lambda> RPAREN
        => StreamOp::Map(f),
    
    DOT "filter" LPAREN <f:Lambda> RPAREN
        => StreamOp::Filter(f),
    
    DOT "tap" LPAREN <args:NamedArgList> RPAREN
        => StreamOp::Tap(args),
    
    DOT EMIT LPAREN <args:NamedArgList?> RPAREN
        => StreamOp::Emit(args.unwrap_or_default()),
    
    DOT TO LPAREN <target:Expr> RPAREN
        => StreamOp::To(target),
    
    DOT PATTERN LPAREN <def:PatternDef> RPAREN
        => StreamOp::Pattern(def),
    
    DOT ATTENTION_WINDOW LPAREN <args:NamedArgList> RPAREN
        => StreamOp::AttentionWindow(args),
    
    DOT "concurrent" LPAREN <args:NamedArgList> RPAREN
        => StreamOp::Concurrent(args),
    
    DOT "process" LPAREN <f:Lambda> RPAREN
        => StreamOp::Process(f),
    
    DOT "on_error" LPAREN <f:Lambda> RPAREN
        => StreamOp::OnError(f),
    
    DOT "collect" LPAREN RPAREN
        => StreamOp::Collect,
    
    // Temporal sequence operators (-> syntax parsed specially in hand-written parser)
    // -> EventType where cond as alias
    DOT "within" LPAREN <duration:Expr> RPAREN
        => StreamOp::Within(duration),
    
    DOT "not" LPAREN <event:Identifier> <filter:(WHERE <Expr>)?> RPAREN
        => StreamOp::Not(FollowedByClause { event_type: event, filter, alias: None, match_all: false }),
};

// NOTE: The -> (FollowedBy) operator is parsed specially:
//   stream S = EventA as a -> EventB where b.ref == a.id as b .within(5s)
// This produces StreamOp::FollowedBy(FollowedByClause { ... })
// See parser.rs parse_followed_by() for implementation.

// ============================================================================
// EVENT DECLARATIONS
// ============================================================================

EventDecl: Stmt = {
    EVENT <name:Identifier> <extends:(EXTENDS <Identifier>)?> COLON <fields:FieldList>
        => Stmt::EventDecl { name, extends, fields },
};

FieldList: Vec<Field> = {
    <fields:Field+> => fields,
};

Field: Field = {
    <name:Identifier> COLON <ty:Type>
        => Field { name, ty, optional: false },
    
    <name:Identifier> COLON <ty:Type> QMARK
        => Field { name, ty, optional: true },
};

// ============================================================================
// TYPE DECLARATIONS
// ============================================================================

TypeDecl: Stmt = {
    TYPE <name:Identifier> EQ <ty:Type>
        => Stmt::TypeDecl { name, ty },
};

Type: Type = {
    PrimitiveType,
    ArrayType,
    MapType,
    TupleType,
    OptionalType,
    StreamType,
    <id:Identifier> => Type::Named(id),
};

PrimitiveType: Type = {
    INT_TYPE => Type::Int,
    FLOAT_TYPE => Type::Float,
    BOOL_TYPE => Type::Bool,
    STR_TYPE => Type::Str,
    TIMESTAMP_TYPE => Type::Timestamp,
    DURATION_TYPE => Type::Duration,
};

ArrayType: Type = {
    LBRACKET <ty:Type> RBRACKET => Type::Array(Box::new(ty)),
};

MapType: Type = {
    LBRACE <key:Type> COLON <val:Type> RBRACE => Type::Map(Box::new(key), Box::new(val)),
};

TupleType: Type = {
    LPAREN <first:Type> COMMA <rest:TypeList> RPAREN 
        => Type::Tuple(std::iter::once(first).chain(rest).collect()),
};

TypeList: Vec<Type> = {
    <first:Type> <rest:(COMMA <Type>)*> => std::iter::once(first).chain(rest).collect(),
};

OptionalType: Type = {
    <ty:Type> QMARK => Type::Optional(Box::new(ty)),
};

StreamType: Type = {
    STREAM_TYPE LT <ty:Type> GT => Type::Stream(Box::new(ty)),
};

// ============================================================================
// VARIABLE DECLARATIONS
// ============================================================================

VarDecl: Stmt = {
    LET <name:Identifier> <ty:(COLON <Type>)?> EQ <value:Expr>
        => Stmt::VarDecl { mutable: false, name, ty, value },
    
    VAR <name:Identifier> <ty:(COLON <Type>)?> EQ <value:Expr>
        => Stmt::VarDecl { mutable: true, name, ty, value },
    
    CONST <name:Identifier> <ty:(COLON <Type>)?> EQ <value:Expr>
        => Stmt::ConstDecl { name, ty, value },
};

// ============================================================================
// FUNCTION DECLARATIONS
// ============================================================================

FnDecl: Stmt = {
    FN <name:Identifier> LPAREN <params:ParamList?> RPAREN <ret:(RARROW <Type>)?> COLON <body:Block>
        => Stmt::FnDecl { name, params: params.unwrap_or_default(), ret, body },
};

ParamList: Vec<Param> = {
    <first:Param> <rest:(COMMA <Param>)*> 
        => std::iter::once(first).chain(rest).collect(),
};

Param: Param = {
    <name:Identifier> COLON <ty:Type> => Param { name, ty },
};

Block: Vec<Stmt> = {
    <stmts:Stmt+> => stmts,
};

// ============================================================================
// EXPRESSIONS
// ============================================================================

Expr: Expr = {
    OrExpr,
};

OrExpr: Expr = {
    <left:OrExpr> OR <right:AndExpr> 
        => Expr::Binary { op: BinOp::Or, left: Box::new(left), right: Box::new(right) },
    AndExpr,
};

AndExpr: Expr = {
    <left:AndExpr> AND <right:NotExpr>
        => Expr::Binary { op: BinOp::And, left: Box::new(left), right: Box::new(right) },
    NotExpr,
};

NotExpr: Expr = {
    NOT <expr:NotExpr> => Expr::Unary { op: UnaryOp::Not, expr: Box::new(expr) },
    ComparisonExpr,
};

ComparisonExpr: Expr = {
    <left:BitwiseOrExpr> <op:CompOp> <right:BitwiseOrExpr>
        => Expr::Binary { op, left: Box::new(left), right: Box::new(right) },
    BitwiseOrExpr,
};

CompOp: BinOp = {
    EQEQ => BinOp::Eq,
    NEQ => BinOp::NotEq,
    LT => BinOp::Lt,
    LE => BinOp::Le,
    GT => BinOp::Gt,
    GE => BinOp::Ge,
    IN => BinOp::In,
    NOT IN => BinOp::NotIn,
    IS => BinOp::Is,
};

BitwiseOrExpr: Expr = {
    <left:BitwiseOrExpr> PIPE <right:BitwiseXorExpr>
        => Expr::Binary { op: BinOp::BitOr, left: Box::new(left), right: Box::new(right) },
    BitwiseXorExpr,
};

BitwiseXorExpr: Expr = {
    <left:BitwiseXorExpr> CARET <right:BitwiseAndExpr>
        => Expr::Binary { op: BinOp::BitXor, left: Box::new(left), right: Box::new(right) },
    BitwiseAndExpr,
};

BitwiseAndExpr: Expr = {
    <left:BitwiseAndExpr> AMP <right:ShiftExpr>
        => Expr::Binary { op: BinOp::BitAnd, left: Box::new(left), right: Box::new(right) },
    ShiftExpr,
};

ShiftExpr: Expr = {
    <left:ShiftExpr> LSHIFT <right:AdditiveExpr>
        => Expr::Binary { op: BinOp::Shl, left: Box::new(left), right: Box::new(right) },
    <left:ShiftExpr> RSHIFT <right:AdditiveExpr>
        => Expr::Binary { op: BinOp::Shr, left: Box::new(left), right: Box::new(right) },
    AdditiveExpr,
};

AdditiveExpr: Expr = {
    <left:AdditiveExpr> PLUS <right:MultiplicativeExpr>
        => Expr::Binary { op: BinOp::Add, left: Box::new(left), right: Box::new(right) },
    <left:AdditiveExpr> MINUS <right:MultiplicativeExpr>
        => Expr::Binary { op: BinOp::Sub, left: Box::new(left), right: Box::new(right) },
    MultiplicativeExpr,
};

MultiplicativeExpr: Expr = {
    <left:MultiplicativeExpr> STAR <right:PowerExpr>
        => Expr::Binary { op: BinOp::Mul, left: Box::new(left), right: Box::new(right) },
    <left:MultiplicativeExpr> SLASH <right:PowerExpr>
        => Expr::Binary { op: BinOp::Div, left: Box::new(left), right: Box::new(right) },
    <left:MultiplicativeExpr> PERCENT <right:PowerExpr>
        => Expr::Binary { op: BinOp::Mod, left: Box::new(left), right: Box::new(right) },
    PowerExpr,
};

PowerExpr: Expr = {
    <base:UnaryExpr> DOUBLESTAR <exp:PowerExpr>
        => Expr::Binary { op: BinOp::Pow, left: Box::new(base), right: Box::new(exp) },
    UnaryExpr,
};

UnaryExpr: Expr = {
    MINUS <expr:UnaryExpr> => Expr::Unary { op: UnaryOp::Neg, expr: Box::new(expr) },
    TILDE <expr:UnaryExpr> => Expr::Unary { op: UnaryOp::BitNot, expr: Box::new(expr) },
    PostfixExpr,
};

PostfixExpr: Expr = {
    <expr:PostfixExpr> DOT <member:Identifier>
        => Expr::Member { expr: Box::new(expr), member },
    
    <expr:PostfixExpr> QDOT <member:Identifier>
        => Expr::OptionalMember { expr: Box::new(expr), member },
    
    <expr:PostfixExpr> LBRACKET <index:Expr> RBRACKET
        => Expr::Index { expr: Box::new(expr), index: Box::new(index) },
    
    <expr:PostfixExpr> LPAREN <args:ArgList?> RPAREN
        => Expr::Call { func: Box::new(expr), args: args.unwrap_or_default() },
    
    PrimaryExpr,
};

PrimaryExpr: Expr = {
    Literal,
    <id:Identifier> => Expr::Ident(id),
    LPAREN <expr:Expr> RPAREN => expr,
    ArrayLiteral,
    MapLiteral,
    Lambda,
    IfExpr,
};

// ============================================================================
// LITERALS
// ============================================================================

Literal: Expr = {
    <n:INTEGER> => Expr::Int(i64::from_str(n).unwrap()),
    <n:FLOAT> => Expr::Float(f64::from_str(n).unwrap()),
    <s:STRING> => Expr::String(s[1..s.len()-1].to_string()),
    <s:STRING_SINGLE> => Expr::String(s[1..s.len()-1].to_string()),
    <d:DURATION> => Expr::Duration(parse_duration(d)),
    <t:TIMESTAMP> => Expr::Timestamp(parse_timestamp(t)),
    TRUE => Expr::Bool(true),
    FALSE => Expr::Bool(false),
    NULL => Expr::Null,
};

ArrayLiteral: Expr = {
    LBRACKET <items:ExprList?> RBRACKET 
        => Expr::Array(items.unwrap_or_default()),
};

MapLiteral: Expr = {
    LBRACE <entries:MapEntryList?> RBRACE
        => Expr::Map(entries.unwrap_or_default()),
};

MapEntryList: Vec<(String, Expr)> = {
    <first:MapEntry> <rest:(COMMA <MapEntry>)*>
        => std::iter::once(first).chain(rest).collect(),
};

MapEntry: (String, Expr) = {
    <key:STRING> COLON <val:Expr> => (key[1..key.len()-1].to_string(), val),
    <key:Identifier> COLON <val:Expr> => (key, val),
};

// ============================================================================
// LAMBDAS
// ============================================================================

Lambda: Expr = {
    <param:Identifier> ARROW <body:Expr>
        => Expr::Lambda { params: vec![param], body: Box::new(body) },
    
    LPAREN <params:IdentList?> RPAREN ARROW <body:Expr>
        => Expr::Lambda { params: params.unwrap_or_default(), body: Box::new(body) },
};

IdentList: Vec<String> = {
    <first:Identifier> <rest:(COMMA <Identifier>)*>
        => std::iter::once(first).chain(rest).collect(),
};

// ============================================================================
// IF EXPRESSION
// ============================================================================

IfExpr: Expr = {
    IF <cond:Expr> "then" <then_branch:Expr> ELSE <else_branch:Expr>
        => Expr::If { 
            cond: Box::new(cond), 
            then_branch: Box::new(then_branch),
            else_branch: Box::new(else_branch)
        },
};

// ============================================================================
// HELPER RULES
// ============================================================================

Identifier: String = {
    <s:IDENTIFIER> => s.to_string(),
};

ExprList: Vec<Expr> = {
    <first:Expr> <rest:(COMMA <Expr>)*>
        => std::iter::once(first).chain(rest).collect(),
};

ArgList: Vec<Arg> = {
    <first:Arg> <rest:(COMMA <Arg>)*>
        => std::iter::once(first).chain(rest).collect(),
};

Arg: Arg = {
    <expr:Expr> => Arg::Positional(expr),
    <name:Identifier> COLON <expr:Expr> => Arg::Named(name, expr),
};

NamedArgList: Vec<(String, Expr)> = {
    <first:NamedArg> <rest:(COMMA <NamedArg>)*>
        => std::iter::once(first).chain(rest).collect(),
};

NamedArg: (String, Expr) = {
    <name:Identifier> COLON <expr:Expr> => (name, expr),
};

SelectList: Vec<SelectItem> = {
    <first:SelectItem> <rest:(COMMA <SelectItem>)*>
        => std::iter::once(first).chain(rest).collect(),
};

SelectItem: SelectItem = {
    <name:Identifier> => SelectItem::Field(name),
    <alias:Identifier> COLON <expr:Expr> => SelectItem::Alias(alias, expr),
};

AggList: Vec<AggItem> = {
    <first:AggItem> <rest:(COMMA <AggItem>)*>
        => std::iter::once(first).chain(rest).collect(),
};

AggItem: AggItem = {
    // NOTE: AST uses `expr: Expr` not `func` + `arg`
    // The parser accepts full expressions like: avg: sum(x) / count(x)
    <alias:Identifier> COLON <expr:Expr>
        => AggItem { alias, expr },
};

OrderList: Vec<OrderItem> = {
    <first:OrderItem> <rest:(COMMA <OrderItem>)*>
        => std::iter::once(first).chain(rest).collect(),
};

OrderItem: OrderItem = {
    // NOTE: AST uses `descending: bool` not `desc`
    <expr:Expr> => OrderItem { expr, descending: false },
    <expr:Expr> "asc" => OrderItem { expr, descending: false },
    <expr:Expr> "desc" => OrderItem { expr, descending: true },
};

WindowArgs: WindowArgs = {
    <duration:Expr> <sliding:(COMMA "sliding" COLON <Expr>)?> <policy:(COMMA "policy" COLON <Expr>)?>
        => WindowArgs { duration, sliding, policy },
};

PatternDef: PatternDef = {
    <name:Identifier> COLON <matcher:Lambda>
        => PatternDef { name, matcher },
};

// ============================================================================
// CONFIG BLOCK
// ============================================================================

ConfigBlock: Stmt = {
    CONFIG COLON <items:ConfigItems>
        => Stmt::Config(items),
};

ConfigItems: Vec<ConfigItem> = {
    <items:ConfigItem+> => items,
};

ConfigItem: ConfigItem = {
    <key:Identifier> COLON <value:ConfigValue>
        => ConfigItem::Value(key, value),
    
    <key:Identifier> COLON <nested:ConfigItems>
        => ConfigItem::Nested(key, nested),
};

ConfigValue: ConfigValue = {
    <n:INTEGER> => ConfigValue::Int(i64::from_str(n).unwrap()),
    <n:FLOAT> => ConfigValue::Float(f64::from_str(n).unwrap()),
    <s:STRING> => ConfigValue::String(s[1..s.len()-1].to_string()),
    <d:DURATION> => ConfigValue::Duration(parse_duration(d)),
    TRUE => ConfigValue::Bool(true),
    FALSE => ConfigValue::Bool(false),
    <id:Identifier> => ConfigValue::Ident(id),
};

// ============================================================================
// IMPORT STATEMENT
// ============================================================================

ImportStmt: Stmt = {
    IMPORT <path:STRING> => Stmt::Import(path[1..path.len()-1].to_string()),
    IMPORT <path:STRING> AS <alias:Identifier> => Stmt::ImportAs(path[1..path.len()-1].to_string(), alias),
};

// ============================================================================
// EXPRESSION STATEMENT
// ============================================================================

ExprStmt: Stmt = {
    <expr:Expr> => Stmt::Expr(expr),
};
