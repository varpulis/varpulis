import type { Edge, Node } from '@xyflow/react';
import type { ConnectorConfig, EventDefinition, StreamDefinition } from '../types';

interface NodeData {
  label: string;
  connector?: ConnectorConfig;
  event?: EventDefinition;
  stream?: StreamDefinition;
  patternType?: string;
  pattern?: string;
}

export function generateVPL(nodes: Node<NodeData>[], edges: Edge[]): string {
  const lines: string[] = [];
  lines.push('// Generated by Varpulis Flow Editor');
  lines.push('// ' + new Date().toISOString());
  lines.push('');

  // Group nodes by type
  const sources = nodes.filter(n => n.type === 'source');
  const sinks = nodes.filter(n => n.type === 'sink');
  const events = nodes.filter(n => n.type === 'event');
  const streams = nodes.filter(n => n.type === 'stream');
  const patterns = nodes.filter(n => n.type === 'pattern');

  // Generate source declarations
  if (sources.length > 0) {
    lines.push('// ============ SOURCES ============');
    for (const source of sources) {
      const config = source.data.connector;
      if (config) {
        lines.push(generateSourceDeclaration(source.data.label, config));
      }
    }
    lines.push('');
  }

  // Generate event type declarations
  if (events.length > 0) {
    lines.push('// ============ EVENTS ============');
    for (const event of events) {
      lines.push(generateEventDeclaration(event.data.label, event.data.event));
    }
    lines.push('');
  }

  // Generate streams
  if (streams.length > 0 || patterns.length > 0) {
    lines.push('// ============ STREAMS ============');
    
    // Find connected patterns for each stream
    for (const stream of streams) {
      const connectedPatterns = findConnectedPatterns(stream.id, patterns, edges);
      lines.push(generateStreamDeclaration(stream.data.label, stream.data.stream, connectedPatterns));
    }
    lines.push('');
  }

  // Generate sink declarations
  if (sinks.length > 0) {
    lines.push('// ============ SINKS ============');
    for (const sink of sinks) {
      const config = sink.data.connector;
      if (config) {
        // Find what stream connects to this sink
        const sourceEdge = edges.find(e => e.target === sink.id);
        const sourceNode = sourceEdge ? nodes.find(n => n.id === sourceEdge.source) : null;
        const streamName = sourceNode?.data.label || 'output_stream';
        lines.push(generateSinkDeclaration(sink.data.label, config, streamName));
      }
    }
    lines.push('');
  }

  return lines.join('\n');
}

function generateSourceDeclaration(name: string, config: ConnectorConfig): string {
  const safeName = toIdentifier(name);
  
  switch (config.type) {
    case 'mqtt':
      return `source ${safeName} from mqtt("${config.host || 'localhost'}:${config.port || 1883}", "${config.topic || 'events'}");`;
    case 'kafka':
      return `source ${safeName} from kafka(["${config.brokers?.join('", "') || 'localhost:9092'}"], "${config.topic || 'events'}", "${config.groupId || 'varpulis'}");`;
    case 'amqp':
      return `source ${safeName} from amqp("${config.host || 'localhost'}:${config.port || 5672}", "${config.queue || 'events'}");`;
    case 'file':
      return `source ${safeName} from file("${config.path || './events.evt'}");`;
    case 'http':
      return `source ${safeName} from http("${config.url || 'http://localhost:8080/events'}");`;
    default:
      return `// Unknown source type: ${config.type}`;
  }
}

function generateEventDeclaration(name: string, event?: EventDefinition): string {
  const safeName = toIdentifier(name);
  
  if (!event || !event.fields || event.fields.length === 0) {
    return `event ${safeName} { }`;
  }

  const fields = event.fields.map(f => `    ${f.name}: ${f.type}`).join(',\n');
  return `event ${safeName} {\n${fields}\n}`;
}

function generateStreamDeclaration(
  name: string, 
  stream?: StreamDefinition,
  connectedPatterns?: Node<NodeData>[]
): string {
  const safeName = toIdentifier(name);
  
  let patternStr = stream?.pattern || 'A';
  
  // If we have connected pattern nodes, build the pattern from them
  if (connectedPatterns && connectedPatterns.length > 0) {
    patternStr = buildPatternFromNodes(connectedPatterns);
  }

  let declaration = `stream ${safeName} {\n`;
  declaration += `    pattern: ${patternStr}`;
  
  if (stream?.window) {
    declaration += `,\n    window: ${stream.window}`;
  }
  
  if (stream?.filters && stream.filters.length > 0) {
    declaration += `,\n    where: ${stream.filters.join(' and ')}`;
  }
  
  declaration += '\n}';
  return declaration;
}

function generateSinkDeclaration(name: string, config: ConnectorConfig, streamName: string): string {
  const safeName = toIdentifier(name);
  const safeStreamName = toIdentifier(streamName);
  
  switch (config.type) {
    case 'console':
      return `sink ${safeName} from ${safeStreamName} to console();`;
    case 'mqtt':
      return `sink ${safeName} from ${safeStreamName} to mqtt("${config.host || 'localhost'}:${config.port || 1883}", "${config.topic || 'output'}");`;
    case 'kafka':
      return `sink ${safeName} from ${safeStreamName} to kafka(["${config.brokers?.join('", "') || 'localhost:9092'}"], "${config.topic || 'output'}");`;
    case 'file':
      return `sink ${safeName} from ${safeStreamName} to file("${config.path || './output.json'}");`;
    case 'http':
      return `sink ${safeName} from ${safeStreamName} to http("${config.url || 'http://localhost:8080/output'}", "${config.method || 'POST'}");`;
    default:
      return `// Unknown sink type: ${config.type}`;
  }
}

function findConnectedPatterns(streamId: string, patterns: Node<NodeData>[], edges: Edge[]): Node<NodeData>[] {
  const connected: Node<NodeData>[] = [];
  
  // Find patterns that connect to this stream
  for (const edge of edges) {
    if (edge.target === streamId) {
      const pattern = patterns.find(p => p.id === edge.source);
      if (pattern) {
        connected.push(pattern);
      }
    }
  }
  
  return connected;
}

function buildPatternFromNodes(patterns: Node<NodeData>[]): string {
  if (patterns.length === 0) return 'A';
  if (patterns.length === 1) {
    const p = patterns[0];
    return p.data.pattern || mapPatternType(p.data.patternType);
  }
  
  // Multiple patterns - join with sequence
  return patterns.map(p => p.data.pattern || mapPatternType(p.data.patternType)).join(' -> ');
}

function mapPatternType(type?: string): string {
  switch (type) {
    case 'sequence': return 'A -> B';
    case 'and': return 'A and B';
    case 'or': return 'A or B';
    case 'not': return 'not A';
    case 'kleene': return 'A+';
    default: return 'A';
  }
}

function toIdentifier(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9_]/g, '_')
    .replace(/^[0-9]/, '_$&')
    .toLowerCase();
}
