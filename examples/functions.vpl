# VarpulisQL - Functions Example
#
# Demonstrates how to write and use reusable functions

# =============================================================================
# CONNECTOR DEFINITIONS
# =============================================================================

connector DataKafka = kafka (
    brokers: ["kafka:9092"],
    group_id: "functions-demo"
)

# =============================================================================
# EVENT DEFINITIONS
# =============================================================================

event Alert:
    severity: str
    message: str
    ts: timestamp

event Measurement:
    value: float
    weight: float
    type: str
    ts: timestamp

event Order:
    id: str
    order_id: str
    amount: float
    status: str
    ts: timestamp

event Payment:
    order_id: str
    amount: float
    ts: timestamp

event SensorReading:
    sensor_id: str
    value: float
    ts: timestamp

event Event:
    value: int
    ts: timestamp

# =============================================================================
# BASE STREAMS
# =============================================================================

stream AlertStream = Alert
    .from(DataKafka, topic: "alerts")

stream MeasurementStream = Measurement
    .from(DataKafka, topic: "measurements")

stream OrderStream = Order
    .from(DataKafka, topic: "orders")

stream PaymentStream = Payment
    .from(DataKafka, topic: "payments")

stream SensorStream = SensorReading
    .from(DataKafka, topic: "sensors")

stream EventStream = Event
    .from(DataKafka, topic: "events")

# =============================================================================
# FUNCTION DECLARATIONS
# =============================================================================

# Simple function with parameters and return type
fn add(a: int, b: int) -> int:
    a + b

# Function without parameters
fn get_threshold() -> float:
    30.5

# Function with single parameter
fn is_critical(severity: str) -> bool:
    severity == "critical"

# Function with complex logic (multi-statement body)
fn calculate_score(value: float, weight: float) -> float:
    let normalized = value / 100.0
    normalized * weight

# Function for validation
fn is_valid_order(amount: float, status: str) -> bool:
    amount > 0 and status != "cancelled"

# Function for formatting
fn format_alert(event_type: str, message: str) -> str:
    "[" + event_type + "] " + message

# =============================================================================
# USING FUNCTIONS IN STREAMS
# =============================================================================

# Use function in filter condition
stream CriticalAlerts = AlertStream
    .where(is_critical(severity))
    .emit(status: "critical_detected")

# Use function in computed values
stream ScoredEvents = MeasurementStream
    .where(calculate_score(value, weight) > 0.8)
    .emit(
        score: calculate_score(value, weight),
        threshold: get_threshold()
    )

# Use function for validation in sequences
stream ValidatedOrders = OrderStream as order
    .where(is_valid_order(amount, status))
    -> PaymentStream where order_id == order.id
    .emit(
        order_id: order.id,
        amount: order.amount
    )

# =============================================================================
# BUILT-IN AGGREGATION FUNCTIONS
# =============================================================================

# These are built-in and work in aggregate operations:
# - count(field)   : Count non-null values
# - sum(field)     : Sum of values
# - avg(field)     : Average value
# - min(field)     : Minimum value
# - max(field)     : Maximum value
# - first(field)   : First value in window
# - last(field)    : Last value in window
# - stddev(field)  : Standard deviation
# - ema(field, n)  : Exponential moving average (period n)

stream Statistics = SensorStream
    .window(5m)
    .aggregate(
        total: sum(value),
        average: avg(value),
        minimum: min(value),
        maximum: max(value),
        count: count(value),
        trend: ema(value, 10)
    )
    .emit(
        total: total,
        average: average,
        range: maximum - minimum
    )

# =============================================================================
# LAMBDA EXPRESSIONS (Inline Functions)
# =============================================================================

# Lambda syntax for inline transformations
stream Mapped = EventStream
    .map(x => x.value * 2)
    .filter(x => x > 100)
    .emit(result: value)

# Lambda with multiple fields
stream Transformed = MeasurementStream
    .map(m => {
        normalized: m.value / 100,
        category: m.type
    })
    .emit(normalized: normalized, category: category)

# =============================================================================
# SINK STATEMENTS
# =============================================================================

sink CriticalAlerts to DataKafka (topic: "critical-alerts")
sink Statistics to console()
