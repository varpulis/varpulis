# Financial Markets - Technical Analysis & Pattern Detection
# Varpulis CEP Engine Example
#
# This example demonstrates real-time trading signals using:
# - Technical indicators (SMA, EMA, RSI, Bollinger Bands, MACD)
# - Pattern detection with attention mechanism
# - Multi-timeframe analysis

# =============================================================================
# Event Definitions
# =============================================================================

event MarketTick:
    symbol: str
    price: float
    volume: int
    bid: float
    ask: float
    ts: timestamp

event OHLCV:
    symbol: str
    open: float
    high: float
    low: float
    close: float
    volume: int
    timeframe: str  # "1m", "5m", "15m", "1h", "4h", "1d"
    ts: timestamp

# =============================================================================
# Base Streams
# =============================================================================

stream Ticks from MarketTick
stream Candles from OHLCV

# Filter by symbol
stream BTCTicks = Ticks.where(symbol == "BTC/USD")
stream ETHTicks = Ticks.where(symbol == "ETH/USD")

# =============================================================================
# Moving Averages (SMA & EMA)
# =============================================================================

# Simple Moving Average - 20 periods (sliding window, emits on every new event)
stream SMA20 = OHLCV
    .where(timeframe == "1m")
    .partition_by(symbol)
    .window(20, sliding: 1)
    .aggregate(
        symbol: last(symbol),
        sma_20: avg(close),
        ts: last(ts)
    )
    .emit(
        event_type: "SMA20",
        symbol: symbol,
        sma_20: sma_20,
        ts: ts
    )

# Simple Moving Average - 50 periods (sliding window, emits on every new event)
stream SMA50 = OHLCV
    .where(timeframe == "1m")
    .partition_by(symbol)
    .window(50, sliding: 1)
    .aggregate(
        symbol: last(symbol),
        sma_50: avg(close),
        ts: last(ts)
    )
    .emit(
        event_type: "SMA50",
        symbol: symbol,
        sma_50: sma_50,
        ts: ts
    )

# Exponential Moving Average - 12 periods (for MACD)
stream EMA12 = OHLCV
    .where(timeframe == "1m")
    .partition_by(symbol)
    .window(12, sliding: 1)
    .aggregate(
        symbol: last(symbol),
        ema_12: ema(close, 12),
        ts: last(ts)
    )

# Exponential Moving Average - 26 periods (for MACD)
stream EMA26 = OHLCV
    .where(timeframe == "1m")
    .partition_by(symbol)
    .window(26, sliding: 1)
    .aggregate(
        symbol: last(symbol),
        ema_26: ema(close, 26),
        ts: last(ts)
    )

# =============================================================================
# MACD (Moving Average Convergence Divergence)
# =============================================================================

stream MACD = join(EMA12, EMA26)
    .on(EMA12.symbol == EMA26.symbol)
    .window(1m)
    .select(
        symbol: EMA12.symbol,
        macd_line: EMA12.ema_12 - EMA26.ema_26,
        ts: EMA12.ts
    )

# MACD Signal Line (9-period EMA of MACD)
stream MACDSignal = MACD
    .partition_by(symbol)
    .window(9, sliding: 1)
    .aggregate(
        symbol: last(symbol),
        macd_line: last(macd_line),
        signal_line: ema(macd_line, 9),
        histogram: last(macd_line) - ema(macd_line, 9),
        ts: last(ts)
    )
    .emit(
        event_type: "MACD",
        symbol: symbol,
        macd_line: macd_line,
        signal_line: signal_line,
        histogram: histogram,
        ts: ts
    )

# =============================================================================
# RSI (Relative Strength Index)
# =============================================================================

stream PriceChanges = OHLCV
    .where(timeframe == "1m")
    .partition_by(symbol)
    .window(2, sliding: 1)
    .aggregate(
        symbol: last(symbol),
        prev_close: first(close),
        curr_close: last(close),
        ts: last(ts)
    )
    .select(
        symbol,
        change: curr_close - prev_close,
        gain: if curr_close > prev_close then curr_close - prev_close else 0,
        loss: if curr_close < prev_close then prev_close - curr_close else 0,
        ts
    )

stream RSI = PriceChanges
    .partition_by(symbol)
    .window(14, sliding: 1)
    .aggregate(
        symbol: last(symbol),
        avg_gain: avg(gain),
        avg_loss: avg(loss),
        ts: last(ts)
    )
    .select(
        symbol,
        avg_gain,
        avg_loss,
        rs: avg_gain / (avg_loss + 0.0001),
        rsi: 100.0 - (100.0 / (1.0 + avg_gain / (avg_loss + 0.0001))),
        ts
    )
    .emit(
        event_type: "RSI",
        symbol: symbol,
        rsi: rsi,
        avg_gain: avg_gain,
        avg_loss: avg_loss,
        ts: ts
    )

# =============================================================================
# Bollinger Bands
# =============================================================================

stream BollingerBands = OHLCV
    .where(timeframe == "1m")
    .partition_by(symbol)
    .window(20, sliding: 1)
    .aggregate(
        symbol: last(symbol),
        close: last(close),
        sma: avg(close),
        std_dev: stddev(close),
        ts: last(ts)
    )
    .select(
        symbol,
        close,
        middle_band: sma,
        upper_band: sma + 2 * std_dev,
        lower_band: sma - 2 * std_dev,
        bandwidth: (sma + 2 * std_dev - (sma - 2 * std_dev)) / sma * 100,
        percent_b: (close - (sma - 2 * std_dev)) / ((sma + 2 * std_dev) - (sma - 2 * std_dev)),
        ts
    )
    .emit(
        event_type: "BollingerBands",
        symbol: symbol,
        middle: middle_band,
        upper: upper_band,
        lower: lower_band,
        bandwidth: bandwidth,
        ts: ts
    )

# =============================================================================
# Combined Technical Indicators
# =============================================================================

stream TechnicalAnalysis = join(
    SMA20,
    SMA50,
    RSI,
    BollingerBands,
    MACDSignal
)
.on(
    SMA20.symbol == SMA50.symbol and
    SMA50.symbol == RSI.symbol and
    RSI.symbol == BollingerBands.symbol and
    BollingerBands.symbol == MACDSignal.symbol
)
.window(1m)
.select(
    symbol: SMA20.symbol,
    price: BollingerBands.close,
    sma_20: SMA20.sma_20,
    sma_50: SMA50.sma_50,
    rsi: RSI.rsi,
    bb_upper: BollingerBands.upper_band,
    bb_lower: BollingerBands.lower_band,
    bb_percent_b: BollingerBands.percent_b,
    macd: MACDSignal.macd_line,
    macd_signal: MACDSignal.signal_line,
    macd_histogram: MACDSignal.histogram,
    ts: SMA20.ts
)

# =============================================================================
# Trading Signals
# =============================================================================

# Golden Cross (SMA20 crosses above SMA50) - Bullish
stream GoldenCross = TechnicalAnalysis
    .partition_by(symbol)
    .window(2)
    .where(
        first(sma_20) < first(sma_50) and
        last(sma_20) > last(sma_50)
    )
    .emit(
        signal_type: "GOLDEN_CROSS",
        direction: "BUY",
        symbol: last(symbol),
        price: last(price),
        confidence: 0.7,
        reason: "SMA20 crossed above SMA50 - bullish trend reversal"
    )

# Death Cross (SMA20 crosses below SMA50) - Bearish
stream DeathCross = TechnicalAnalysis
    .partition_by(symbol)
    .window(2)
    .where(
        first(sma_20) > first(sma_50) and
        last(sma_20) < last(sma_50)
    )
    .emit(
        signal_type: "DEATH_CROSS",
        direction: "SELL",
        symbol: last(symbol),
        price: last(price),
        confidence: 0.7,
        reason: "SMA20 crossed below SMA50 - bearish trend reversal"
    )

# RSI Oversold (RSI < 30) - Potential Buy
stream RSIOversold = TechnicalAnalysis
    .where(rsi < 30)
    .emit(
        signal_type: "RSI_OVERSOLD",
        direction: "BUY",
        symbol: symbol,
        price: price,
        rsi: rsi,
        confidence: 0.6,
        reason: "RSI below 30 - asset may be oversold"
    )

# RSI Overbought (RSI > 70) - Potential Sell
stream RSIOverbought = TechnicalAnalysis
    .where(rsi > 70)
    .emit(
        signal_type: "RSI_OVERBOUGHT",
        direction: "SELL",
        symbol: symbol,
        price: price,
        rsi: rsi,
        confidence: 0.6,
        reason: "RSI above 70 - asset may be overbought"
    )

# Bollinger Band Squeeze (Low volatility, potential breakout)
stream BBSqueeze = BollingerBands
    .where(bandwidth < 5)
    .emit(
        signal_type: "BB_SQUEEZE",
        direction: "WATCH",
        symbol: symbol,
        price: close,
        bandwidth: bandwidth,
        confidence: 0.5,
        reason: "Bollinger Bands squeeze - expect volatility breakout"
    )

# Bollinger Band Breakout (Price above upper band)
stream BBBreakoutUp = BollingerBands
    .where(close > upper_band)
    .emit(
        signal_type: "BB_BREAKOUT_UP",
        direction: "BUY",
        symbol: symbol,
        price: close,
        upper_band: upper_band,
        confidence: 0.65,
        reason: "Price broke above upper Bollinger Band"
    )

# Bollinger Band Breakdown (Price below lower band)
stream BBBreakoutDown = BollingerBands
    .where(close < lower_band)
    .emit(
        signal_type: "BB_BREAKOUT_DOWN",
        direction: "SELL",
        symbol: symbol,
        price: close,
        lower_band: lower_band,
        confidence: 0.65,
        reason: "Price broke below lower Bollinger Band"
    )

# MACD Bullish Crossover
stream MACDBullish = MACDSignal
    .partition_by(symbol)
    .window(2)
    .where(
        first(macd_line) < first(signal_line) and
        last(macd_line) > last(signal_line)
    )
    .emit(
        signal_type: "MACD_BULLISH",
        direction: "BUY",
        symbol: last(symbol),
        macd: last(macd_line),
        signal: last(signal_line),
        confidence: 0.65,
        reason: "MACD crossed above signal line"
    )

# MACD Bearish Crossover
stream MACDBearish = MACDSignal
    .partition_by(symbol)
    .window(2)
    .where(
        first(macd_line) > first(signal_line) and
        last(macd_line) < last(signal_line)
    )
    .emit(
        signal_type: "MACD_BEARISH",
        direction: "SELL",
        symbol: last(symbol),
        macd: last(macd_line),
        signal: last(signal_line),
        confidence: 0.65,
        reason: "MACD crossed below signal line"
    )

# =============================================================================
# Multi-Signal Confluence (Higher confidence)
# =============================================================================

stream StrongBuySignal = TechnicalAnalysis
    .where(
        rsi < 35 and
        bb_percent_b < 0.2 and
        macd_histogram > 0 and
        sma_20 > sma_50
    )
    .emit(
        signal_type: "STRONG_BUY",
        direction: "BUY",
        symbol: symbol,
        price: price,
        confidence: 0.85,
        indicators: {
            rsi: rsi,
            bb_percent_b: bb_percent_b,
            macd_histogram: macd_histogram,
            trend: "bullish"
        },
        reason: "Multiple bullish indicators aligned: RSI oversold, price near lower BB, positive MACD histogram, uptrend"
    )

stream StrongSellSignal = TechnicalAnalysis
    .where(
        rsi > 65 and
        bb_percent_b > 0.8 and
        macd_histogram < 0 and
        sma_20 < sma_50
    )
    .emit(
        signal_type: "STRONG_SELL",
        direction: "SELL",
        symbol: symbol,
        price: price,
        confidence: 0.85,
        indicators: {
            rsi: rsi,
            bb_percent_b: bb_percent_b,
            macd_histogram: macd_histogram,
            trend: "bearish"
        },
        reason: "Multiple bearish indicators aligned: RSI overbought, price near upper BB, negative MACD histogram, downtrend"
    )

# =============================================================================
# Pattern Detection with Attention (Advanced)
# =============================================================================

# Anomalous activity detection using attention window
# Only emits when attention score is high (strong correlation between recent events)
stream AnomalousActivity = Ticks
    .partition_by(symbol)
    .attention_window(
        duration: 5m,
        heads: 4,
        embedding: "rule_based"
    )
    .where(attention_score > 0.7 and attention_matches > 5)
    .emit(
        signal_type: "PUMP_DETECTED",
        direction: "CAUTION",
        symbol: symbol,
        confidence: 0.75,
        attention_score: attention_score,
        attention_matches: attention_matches,
        correlation_strength: attention_context_norm,
        reason: "High attention score - correlated price/volume activity detected"
    )

# =============================================================================
# Temporal Sequence Patterns (using -> operator)
# =============================================================================

# News-Driven Price Movement Detection
# Detect when a news event is followed by significant price movement
stream NewsDrivenMove = NewsEvent as news
    -> MarketTick where symbol == news.symbol and price > news.pre_price * 1.02 as spike
    .within(5m)
    .emit(
        signal_type: "NEWS_DRIVEN_SPIKE",
        symbol: news.symbol,
        news_headline: news.headline,
        price_change: (spike.price - news.pre_price) / news.pre_price,
        reaction_time: spike.ts - news.ts
    )

# Pump and Dump Detection Sequence
# Detect rapid price increase followed by volume spike and then price drop
stream PumpAndDump = MarketTick as pump_start
    -> MarketTick where symbol == pump_start.symbol and price >= pump_start.price * 1.10 as peak
    .within(30m)
    -> MarketTick where symbol == pump_start.symbol and price <= peak.price * 0.85 as dump
    .within(1h)
    .emit(
        signal_type: "PUMP_AND_DUMP",
        direction: "ALERT",
        symbol: pump_start.symbol,
        pump_gain: (peak.price - pump_start.price) / pump_start.price,
        dump_loss: (dump.price - peak.price) / peak.price,
        confidence: 0.9
    )

# Order Fill Sequence (for execution quality analysis)
stream OrderExecution = OrderSubmit as order
    -> OrderAck where order_id == order.id as ack
    .within(100ms)
    -> OrderFill where order_id == order.id as fill
    .within(1s)
    .emit(
        signal_type: "ORDER_EXECUTED",
        order_id: order.id,
        symbol: order.symbol,
        ack_latency: ack.ts - order.ts,
        fill_latency: fill.ts - order.ts,
        slippage: fill.price - order.limit_price
    )

# =============================================================================
# Aggregate All Signals
# =============================================================================

stream AllSignals = merge(
    GoldenCross,
    DeathCross,
    RSIOversold,
    RSIOverbought,
    BBSqueeze,
    BBBreakoutUp,
    BBBreakoutDown,
    MACDBullish,
    MACDBearish,
    StrongBuySignal,
    StrongSellSignal,
    AnomalousActivity
)
.tap(counter: "trading_signals_total", labels: [signal_type, direction])
.emit()

# =============================================================================
# Configuration
# =============================================================================

config:
    mode: "low_latency"
    state_backend: "rocksdb"
    state_path: "/var/lib/varpulis/financial"
    metrics_enabled: true
    metrics_endpoint: "0.0.0.0:9090"
    tracing_enabled: true
    tracing_sample_rate: 0.1
