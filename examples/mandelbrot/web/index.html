<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot Set - Parallel Contexts Demo</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { margin-bottom: 10px; color: #f39c12; }
        .info { font-size: 14px; color: #888; margin-bottom: 20px; text-align: center; }
        #canvas-container {
            position: relative;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }
        #canvas { display: block; background: #000; }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 13px;
            font-family: monospace;
        }
        .stat-label { color: #888; }
        .stat-value { color: #f39c12; font-weight: bold; }
        #status {
            margin-top: 15px;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
        }
        .status-connecting { background: #2c3e50; }
        .status-connected { background: #27ae60; }
        .status-computing { background: #e67e22; }
        .status-error { background: #c0392b; }
        .status-complete { background: #8e44ad; }
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 25px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover { transform: translateY(-2px); }
        #startBtn { background: #27ae60; color: white; }
        #startBtn:disabled { background: #555; cursor: not-allowed; transform: none; }
        #resetBtn { background: #e74c3c; color: white; }
        .context-grid {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            font-size: 11px;
            font-family: monospace;
        }
        .context-cell {
            padding: 5px;
            background: #2c3e50;
            border-radius: 3px;
            text-align: center;
        }
        .context-cell.active { background: #e67e22; }
        .context-cell.done { background: #27ae60; }
    </style>
</head>
<body>
    <h1>Mandelbrot Set - Parallel</h1>
    <div class="info">
        16 contexts compute 250x250 tiles in parallel<br>
        Row events stream via MQTT WebSocket (4,000 messages)
    </div>

    <div id="canvas-container">
        <canvas id="canvas" width="1000" height="1000"></canvas>
        <div id="stats">
            <div><span class="stat-label">Pixels:</span> <span class="stat-value" id="pixel-count">0</span> / 1,000,000</div>
            <div><span class="stat-label">Rows:</span> <span class="stat-value" id="row-count">0</span> / 4,000</div>
            <div><span class="stat-label">Progress:</span> <span class="stat-value" id="progress">0%</span></div>
            <div><span class="stat-label">Time:</span> <span class="stat-value" id="elapsed">0.0s</span></div>
            <div><span class="stat-label">Rate:</span> <span class="stat-value" id="rate">0</span> px/s</div>
        </div>
    </div>

    <div id="status" class="status-connecting">Connecting to MQTT...</div>

    <div class="context-grid" id="context-grid"></div>

    <div id="controls">
        <button id="startBtn" disabled>Start Computation</button>
        <button id="resetBtn">Reset</button>
    </div>

    <script>
        const SIZE = 1000;
        const MAX_ITER = 256;
        const TOTAL_PIXELS = SIZE * SIZE;
        const TOTAL_ROWS = 4000; // 16 tiles x 250 rows
        const NUM_CONTEXTS = 16;
        const TILE_SIZE = 250;

        const canvas = document.getElementById('canvas');
        const canvasCtx = canvas.getContext('2d');
        const imageData = canvasCtx.createImageData(SIZE, SIZE);

        // Inferno colormap (precomputed LUT for performance)
        const colorLut = new Uint8Array((MAX_ITER + 1) * 3);
        for (let i = 0; i <= MAX_ITER; i++) {
            if (i >= MAX_ITER) {
                colorLut[i * 3] = 0;
                colorLut[i * 3 + 1] = 0;
                colorLut[i * 3 + 2] = 0;
            } else {
                const t = Math.log1p(i) / Math.log1p(MAX_ITER);
                colorLut[i * 3] = Math.min(255, Math.floor(255 * (1.5 * t)));
                colorLut[i * 3 + 1] = Math.min(255, Math.floor(255 * (t * t)));
                colorLut[i * 3 + 2] = Math.min(255, Math.floor(255 * (0.5 + 0.5 * Math.sin(Math.PI * t))));
            }
        }

        let pixelCount = 0;
        let rowCount = 0;
        let startTime = null;
        let pipelineId = null;
        let mqttClient = null;
        let contextStatus = Array(NUM_CONTEXTS).fill('pending');

        const statusEl = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const contextGrid = document.getElementById('context-grid');

        // Build context grid UI
        for (let i = 0; i < NUM_CONTEXTS; i++) {
            const row = Math.floor(i / 4);
            const col = i % 4;
            const cell = document.createElement('div');
            cell.className = 'context-cell';
            cell.id = `ctx-${row}${col}`;
            cell.textContent = `t${row}${col}`;
            contextGrid.appendChild(cell);
        }

        function updateContextUI() {
            for (let i = 0; i < NUM_CONTEXTS; i++) {
                const row = Math.floor(i / 4);
                const col = i % 4;
                const cell = document.getElementById(`ctx-${row}${col}`);
                cell.className = 'context-cell ' + contextStatus[i];
            }
        }

        function updateStats() {
            document.getElementById('pixel-count').textContent = pixelCount.toLocaleString();
            document.getElementById('row-count').textContent = rowCount.toLocaleString();
            document.getElementById('progress').textContent = (100 * pixelCount / TOTAL_PIXELS).toFixed(1) + '%';

            if (startTime) {
                const elapsed = (Date.now() - startTime) / 1000;
                document.getElementById('elapsed').textContent = elapsed.toFixed(1) + 's';
                document.getElementById('rate').textContent = Math.round(pixelCount / elapsed).toLocaleString();
            }
        }

        // Process a full row of pixels from comma-separated iteration data
        function setPixelRow(y, xStart, count, rowData) {
            if (y < 0 || y >= SIZE) return;

            const iterations = rowData.split(',');
            const len = Math.min(iterations.length, count, SIZE - xStart);
            const data = imageData.data;

            for (let i = 0; i < len; i++) {
                const x = xStart + i;
                if (x < 0 || x >= SIZE) continue;

                const iter = parseInt(iterations[i], 10);
                const idx = (y * SIZE + x) * 4;
                const ci = Math.min(iter, MAX_ITER) * 3;

                data[idx] = colorLut[ci];
                data[idx + 1] = colorLut[ci + 1];
                data[idx + 2] = colorLut[ci + 2];
                data[idx + 3] = 255;
            }

            pixelCount += len;
            rowCount++;

            // Track which tile this row belongs to
            const tileRow = Math.floor(y / TILE_SIZE);
            const tileCol = Math.floor(xStart / TILE_SIZE);
            const tileIdx = tileRow * 4 + tileCol;
            if (contextStatus[tileIdx] !== 'done') {
                contextStatus[tileIdx] = 'active';
            }
        }

        let renderPending = false;
        function scheduleRender() {
            if (!renderPending) {
                renderPending = true;
                requestAnimationFrame(() => {
                    canvasCtx.putImageData(imageData, 0, 0);
                    updateStats();
                    updateContextUI();
                    renderPending = false;

                    if (pixelCount >= TOTAL_PIXELS) {
                        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                        statusEl.textContent = `Complete! (${elapsed}s)`;
                        statusEl.className = 'status-complete';
                        startBtn.disabled = false;
                        contextStatus = contextStatus.map(() => 'done');
                        updateContextUI();
                    }
                });
            }
        }

        function reset() {
            pixelCount = 0;
            rowCount = 0;
            startTime = null;
            pipelineId = null;
            contextStatus = Array(NUM_CONTEXTS).fill('pending');
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i] = 0;
                imageData.data[i + 1] = 0;
                imageData.data[i + 2] = 0;
                imageData.data[i + 3] = 255;
            }
            canvasCtx.putImageData(imageData, 0, 0);
            updateStats();
            updateContextUI();
            statusEl.textContent = 'Ready';
            statusEl.className = 'status-connected';
            startBtn.disabled = false;
        }

        function connectMqtt() {
            mqttClient = mqtt.connect('ws://localhost:9001');

            mqttClient.on('connect', () => {
                console.log('MQTT connected');
                mqttClient.subscribe('mandelbrot/pixels/#', { qos: 1 }, (err) => {
                    if (!err) {
                        statusEl.textContent = 'Connected - Ready';
                        statusEl.className = 'status-connected';
                        startBtn.disabled = false;
                    }
                });
            });

            mqttClient.on('message', (topic, message) => {
                try {
                    const event = JSON.parse(message.toString());
                    const d = event.data || event;

                    // Handle PixelRow events (batched row data)
                    if (d.data !== undefined && d.y !== undefined) {
                        setPixelRow(d.y, d.x_start || 0, d.count || 250, d.data);
                        scheduleRender();
                    }
                    // Legacy: handle individual Pixel events
                    else if (d.x !== undefined && d.y !== undefined) {
                        const x = d.x, y = d.y;
                        const iter = d.iterations || 0;
                        const idx = (y * SIZE + x) * 4;
                        const ci = Math.min(iter, MAX_ITER) * 3;
                        imageData.data[idx] = colorLut[ci];
                        imageData.data[idx + 1] = colorLut[ci + 1];
                        imageData.data[idx + 2] = colorLut[ci + 2];
                        imageData.data[idx + 3] = 255;
                        pixelCount++;
                        scheduleRender();
                    }
                } catch (e) {
                    console.error('Parse error:', e);
                }
            });

            mqttClient.on('error', (err) => {
                console.error('MQTT error:', err);
                statusEl.textContent = 'MQTT Error: ' + err.message;
                statusEl.className = 'status-error';
            });
        }

        async function deployPipeline() {
            const vplSource = await fetch('mandelbrot_parallel.vpl').then(r => r.text());

            const response = await fetch('http://localhost:9000/api/v1/pipelines', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': 'test'
                },
                body: JSON.stringify({
                    name: 'mandelbrot-parallel-' + Date.now(),
                    source: vplSource
                })
            });

            if (!response.ok) {
                throw new Error('Deploy failed: ' + await response.text());
            }

            const result = await response.json();
            return result.id;
        }

        async function injectAllTiles() {
            // Inject all 16 tile events in parallel
            const promises = [];
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const eventType = `ComputeTile${row}${col}`;
                    promises.push(
                        fetch(`http://localhost:9000/api/v1/pipelines/${pipelineId}/events`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': 'test'
                            },
                            body: JSON.stringify({
                                event_type: eventType,
                                fields: {}
                            })
                        })
                    );
                }
            }
            await Promise.all(promises);
        }

        async function startComputation() {
            try {
                reset();
                startBtn.disabled = true;
                startTime = Date.now();

                statusEl.textContent = 'Deploying pipeline...';
                statusEl.className = 'status-computing';

                pipelineId = await deployPipeline();
                console.log('Pipeline deployed:', pipelineId);

                statusEl.textContent = 'Injecting events (16 contexts)...';

                // Small delay to ensure MQTT subscription is ready
                await new Promise(r => setTimeout(r, 500));

                await injectAllTiles();
                console.log('All 16 tile events injected');

                statusEl.textContent = 'Computing... (watching MQTT)';

            } catch (e) {
                console.error(e);
                statusEl.textContent = 'Error: ' + e.message;
                statusEl.className = 'status-error';
                startBtn.disabled = false;
            }
        }

        startBtn.addEventListener('click', startComputation);
        resetBtn.addEventListener('click', reset);

        // Connect to MQTT on load
        connectMqtt();

        // Initial render (black canvas)
        for (let i = 0; i < imageData.data.length; i += 4) {
            imageData.data[i + 3] = 255;
        }
        canvasCtx.putImageData(imageData, 0, 0);
    </script>
</body>
</html>
