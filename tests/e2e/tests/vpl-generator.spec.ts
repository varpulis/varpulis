/**
 * VPL Generator Tests
 * 
 * Tests that the flow editor generates valid VPL that:
 * 1. Parses without errors
 * 2. Can be executed by the CLI
 * 3. Matches the syntax of example files
 */

import { expect, test } from '@playwright/test';
import { spawnSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

const TEST_DIR = path.join(__dirname, '..', 'test-output');
const PROJECT_ROOT = path.join(__dirname, '..', '..', '..');
const CLI_PATH = path.join(PROJECT_ROOT, 'target', 'release', 'varpulis');
const EXAMPLES_DIR = path.join(PROJECT_ROOT, 'examples');

// Types for flow graph
interface FlowNode {
  id: string;
  type: 'event' | 'stream' | 'function' | 'config';
  label: string;
  config: Record<string, any>;
}

interface FlowConnection {
  from: string;
  to: string;
}

interface FlowGraph {
  nodes: FlowNode[];
  connections: FlowConnection[];
}

// Check if CLI is available
function cliAvailable(): boolean {
  try {
    const result = spawnSync(CLI_PATH, ['--help'], { timeout: 5000 });
    return result.status === 0;
  } catch {
    return false;
  }
}

// Validate VPL syntax using CLI
function validateVPL(vplContent: string): { valid: boolean; error?: string } {
  const vplPath = path.join(TEST_DIR, `validate-${Date.now()}.vpl`);
  fs.writeFileSync(vplPath, vplContent);
  
  const result = spawnSync(CLI_PATH, ['check', vplPath], {
    timeout: 10000,
    encoding: 'utf-8'
  });
  
  fs.unlinkSync(vplPath);
  
  if (result.status === 0) {
    return { valid: true };
  }
  return { valid: false, error: result.stderr || result.stdout };
}

// Generate VPL from flow graph (this is what the flow editor should do)
function generateVPL(flow: FlowGraph): string {
  let vpl = `# Generated by Varpulis Flow Editor\n# ${new Date().toISOString()}\n\n`;

  const events = flow.nodes.filter(n => n.type === 'event');
  const streams = flow.nodes.filter(n => n.type === 'stream');
  const functions = flow.nodes.filter(n => n.type === 'function');
  const configs = flow.nodes.filter(n => n.type === 'config');

  // Generate functions first
  if (functions.length) {
    vpl += '# =============================================================================\n';
    vpl += '# Functions\n';
    vpl += '# =============================================================================\n\n';
    for (const fn of functions) {
      const { name, params, returnType, body } = fn.config;
      const paramStr = params ? params.map((p: any) => `${p.name}: ${p.type}`).join(', ') : '';
      vpl += `fn ${name}(${paramStr}) -> ${returnType || 'float'}:\n`;
      vpl += `    ${body || '0'}\n\n`;
    }
  }

  // Generate events
  if (events.length) {
    vpl += '# =============================================================================\n';
    vpl += '# Event Definitions\n';
    vpl += '# =============================================================================\n\n';
    for (const evt of events) {
      vpl += `event ${evt.label}:\n`;
      const fields = evt.config.fields || [];
      for (const field of fields) {
        vpl += `    ${field.name}: ${field.type}\n`;
      }
      vpl += '\n';
    }
  }

  // Generate streams
  if (streams.length) {
    vpl += '# =============================================================================\n';
    vpl += '# Streams\n';
    vpl += '# =============================================================================\n\n';
    for (const stream of streams) {
      vpl += generateStreamVPL(stream, flow);
      vpl += '\n';
    }
  }

  // Generate config
  if (configs.length) {
    vpl += '# =============================================================================\n';
    vpl += '# Configuration\n';
    vpl += '# =============================================================================\n\n';
    vpl += 'config:\n';
    for (const cfg of configs) {
      for (const [key, value] of Object.entries(cfg.config)) {
        if (typeof value === 'string') {
          vpl += `    ${key}: "${value}"\n`;
        } else {
          vpl += `    ${key}: ${value}\n`;
        }
      }
    }
  }

  return vpl;
}

// Generate VPL for a single stream
function generateStreamVPL(stream: FlowNode, flow: FlowGraph): string {
  const cfg = stream.config;
  let vpl = '';

  // Find source (connected event or stream)
  const sourceConn = flow.connections.find(c => c.to === stream.id);
  const sourceNode = sourceConn ? flow.nodes.find(n => n.id === sourceConn.from) : null;
  const source = sourceNode?.label || cfg.source || 'Event';

  // Base stream or from clause
  if (cfg.isBase) {
    vpl += `stream ${stream.label} from ${source}\n`;
    return vpl;
  }

  // Stream with operators
  vpl += `stream ${stream.label} = ${source}`;

  // Alias
  if (cfg.alias) {
    vpl += ` as ${cfg.alias}`;
  }

  vpl += '\n';

  // Operators
  if (cfg.partitionBy) {
    vpl += `    .partition_by(${cfg.partitionBy})\n`;
  }

  if (cfg.window) {
    const windowOpts = cfg.windowOpts ? `, ${cfg.windowOpts}` : '';
    vpl += `    .window(${cfg.window}${windowOpts})\n`;
  }

  if (cfg.where) {
    vpl += `    .where(${cfg.where})\n`;
  }

  if (cfg.aggregate) {
    vpl += `    .aggregate(\n`;
    const entries = Object.entries(cfg.aggregate);
    entries.forEach(([key, value], idx) => {
      const comma = idx < entries.length - 1 ? ',' : '';
      vpl += `        ${key}: ${value}${comma}\n`;
    });
    vpl += `    )\n`;
  }

  if (cfg.select) {
    vpl += `    .select(\n`;
    for (const [key, value] of Object.entries(cfg.select)) {
      vpl += `        ${key}: ${value},\n`;
    }
    vpl = vpl.slice(0, -2) + '\n';
    vpl += `    )\n`;
  }

  if (cfg.print) {
    vpl += `    .print(${cfg.print})\n`;
  }

  if (cfg.log) {
    vpl += `    .log(level: "${cfg.log.level}", message: "${cfg.log.message}")\n`;
  }

  // Sequence pattern BEFORE emit
  if (cfg.sequence) {
    for (const seq of cfg.sequence) {
      vpl += `    -> ${seq.event}`;
      if (seq.where) {
        vpl += ` where ${seq.where}`;
      }
      if (seq.alias) {
        vpl += ` as ${seq.alias}`;
      }
      vpl += '\n';
      if (seq.within) {
        vpl += `    .within(${seq.within})\n`;
      }
    }
  }

  if (cfg.emit) {
    vpl += `    .emit(\n`;
    const entries = Object.entries(cfg.emit);
    entries.forEach(([key, value], idx) => {
      // Determine if value is a literal string or a field reference
      const isFieldRef = typeof value === 'string' && 
        (value.match(/^[a-z_][a-z0-9_.]*$/i) || value.includes('(') || value.includes('.'));
      const comma = idx < entries.length - 1 ? ',' : '';
      if (isFieldRef) {
        vpl += `        ${key}: ${value}${comma}\n`;
      } else {
        vpl += `        ${key}: "${value}"${comma}\n`;
      }
    });
    vpl += `    )\n`;
  }

  return vpl;
}

test.beforeAll(async () => {
  if (!fs.existsSync(TEST_DIR)) {
    fs.mkdirSync(TEST_DIR, { recursive: true });
  }
});

test.describe('VPL Generator', () => {
  
  test('CLI is available', async () => {
    expect(cliAvailable()).toBe(true);
  });

  test('Generate simple event and stream', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    const flow: FlowGraph = {
      nodes: [
        {
          id: 'e1',
          type: 'event',
          label: 'SensorReading',
          config: {
            fields: [
              { name: 'sensor_id', type: 'str' },
              { name: 'value', type: 'float' },
              { name: 'ts', type: 'int' }
            ]
          }
        },
        {
          id: 's1',
          type: 'stream',
          label: 'Sensors',
          config: {
            isBase: true,
            source: 'SensorReading'
          }
        },
        {
          id: 's2',
          type: 'stream',
          label: 'HighValues',
          config: {
            source: 'Sensors',
            where: 'value > 100',
            emit: {
              alert_type: 'high_value',
              sensor_id: 'sensor_id',
              value: 'value'
            }
          }
        }
      ],
      connections: [
        { from: 'e1', to: 's1' },
        { from: 's1', to: 's2' }
      ]
    };

    const vpl = generateVPL(flow);
    console.log('Generated VPL:\n', vpl);

    const result = validateVPL(vpl);
    console.log('Validation result:', result);
    
    expect(result.valid).toBe(true);
  });

  test('Generate stream with window and aggregation', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    const flow: FlowGraph = {
      nodes: [
        {
          id: 'e1',
          type: 'event',
          label: 'TemperatureReading',
          config: {
            fields: [
              { name: 'zone', type: 'str' },
              { name: 'value', type: 'float' },
              { name: 'ts', type: 'int' }
            ]
          }
        },
        {
          id: 's1',
          type: 'stream',
          label: 'Temperatures',
          config: { isBase: true, source: 'TemperatureReading' }
        },
        {
          id: 's2',
          type: 'stream',
          label: 'ZoneTemperatures',
          config: {
            source: 'Temperatures',
            partitionBy: 'zone',
            window: '5m',
            aggregate: {
              zone: 'last(zone)',
              avg_temp: 'avg(value)',
              min_temp: 'min(value)',
              max_temp: 'max(value)',
              count: 'count()'
            }
          }
        }
      ],
      connections: [
        { from: 'e1', to: 's1' },
        { from: 's1', to: 's2' }
      ]
    };

    const vpl = generateVPL(flow);
    console.log('Generated VPL:\n', vpl);

    const result = validateVPL(vpl);
    console.log('Validation result:', result);
    
    expect(result.valid).toBe(true);
  });

  test('Generate stream with sequence pattern', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    const flow: FlowGraph = {
      nodes: [
        {
          id: 'e1',
          type: 'event',
          label: 'Order',
          config: {
            fields: [
              { name: 'id', type: 'str' },
              { name: 'amount', type: 'float' },
              { name: 'ts', type: 'int' }
            ]
          }
        },
        {
          id: 'e2',
          type: 'event',
          label: 'Payment',
          config: {
            fields: [
              { name: 'order_id', type: 'str' },
              { name: 'amount', type: 'float' },
              { name: 'ts', type: 'int' }
            ]
          }
        },
        {
          id: 's1',
          type: 'stream',
          label: 'CompletedOrders',
          config: {
            source: 'Order',
            alias: 'order',
            sequence: [
              { event: 'Payment', where: 'order_id == order.id', alias: 'payment', within: '5m' }
            ],
            emit: {
              status: 'completed',
              order_id: 'order.id',
              amount: 'payment.amount'
            }
          }
        }
      ],
      connections: []
    };

    const vpl = generateVPL(flow);
    console.log('Generated VPL:\n', vpl);

    const result = validateVPL(vpl);
    console.log('Validation result:', result);
    
    expect(result.valid).toBe(true);
  });

  test('Generate function definitions', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    const flow: FlowGraph = {
      nodes: [
        {
          id: 'f1',
          type: 'function',
          label: 'is_critical',
          config: {
            name: 'is_critical',
            params: [{ name: 'severity', type: 'str' }],
            returnType: 'bool',
            body: 'severity == "critical"'
          }
        },
        {
          id: 'f2',
          type: 'function',
          label: 'calculate_threshold',
          config: {
            name: 'calculate_threshold',
            params: [{ name: 'baseline', type: 'float' }],
            returnType: 'float',
            body: 'baseline * 1.5'
          }
        },
        {
          id: 'e1',
          type: 'event',
          label: 'Alert',
          config: {
            fields: [
              { name: 'severity', type: 'str' },
              { name: 'message', type: 'str' },
              { name: 'ts', type: 'timestamp' }
            ]
          }
        },
        {
          id: 's1',
          type: 'stream',
          label: 'CriticalAlerts',
          config: {
            source: 'Alert',
            where: 'is_critical(severity)',
            emit: {
              status: 'critical_detected'
            }
          }
        }
      ],
      connections: []
    };

    const vpl = generateVPL(flow);
    console.log('Generated VPL:\n', vpl);

    const result = validateVPL(vpl);
    console.log('Validation result:', result);
    
    expect(result.valid).toBe(true);
  });

  test('Generate HVAC-like monitoring flow', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    // Recreate a simplified version of hvac_demo.vpl
    const flow: FlowGraph = {
      nodes: [
        {
          id: 'e1',
          type: 'event',
          label: 'TemperatureReading',
          config: {
            fields: [
              { name: 'sensor_id', type: 'str' },
              { name: 'zone', type: 'str' },
              { name: 'value', type: 'float' },
              { name: 'ts', type: 'int' }
            ]
          }
        },
        {
          id: 'e2',
          type: 'event',
          label: 'HumidityReading',
          config: {
            fields: [
              { name: 'sensor_id', type: 'str' },
              { name: 'zone', type: 'str' },
              { name: 'value', type: 'float' },
              { name: 'ts', type: 'int' }
            ]
          }
        },
        {
          id: 's1',
          type: 'stream',
          label: 'Temperatures',
          config: { isBase: true, source: 'TemperatureReading' }
        },
        {
          id: 's2',
          type: 'stream',
          label: 'Humidity',
          config: { isBase: true, source: 'HumidityReading' }
        },
        {
          id: 's3',
          type: 'stream',
          label: 'ZoneTemperatures',
          config: {
            source: 'Temperatures',
            partitionBy: 'zone',
            window: '5m',
            aggregate: {
              zone: 'last(zone)',
              avg_temp: 'avg(value)',
              min_temp: 'min(value)',
              max_temp: 'max(value)',
              count: 'count()'
            }
          }
        },
        {
          id: 's4',
          type: 'stream',
          label: 'TemperatureAnomaly',
          config: {
            source: 'ZoneTemperatures',
            where: 'avg_temp < 16.0 or avg_temp > 28.0',
            emit: {
              alert_type: 'TEMPERATURE_ANOMALY',
              severity: 'warning',
              zone: 'zone',
              temperature: 'avg_temp'
            }
          }
        }
      ],
      connections: [
        { from: 'e1', to: 's1' },
        { from: 'e2', to: 's2' },
        { from: 's1', to: 's3' },
        { from: 's3', to: 's4' }
      ]
    };

    const vpl = generateVPL(flow);
    console.log('Generated HVAC-like VPL:\n', vpl);

    // Save for inspection
    fs.writeFileSync(path.join(TEST_DIR, 'hvac-generated.vpl'), vpl);

    const result = validateVPL(vpl);
    console.log('Validation result:', result);
    
    expect(result.valid).toBe(true);
  });

  test('Compare with existing example syntax', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    // Read hvac_demo.vpl to verify syntax patterns
    const hvacExample = fs.readFileSync(path.join(EXAMPLES_DIR, 'hvac_demo.vpl'), 'utf-8');

    // Extract key patterns
    const patterns = {
      eventDecl: /event\s+\w+:\s*\n(\s+\w+:\s+\w+\s*\n)+/g,
      streamBase: /stream\s+\w+\s+from\s+\w+/g,
      streamDef: /stream\s+\w+\s*=\s*\w+/g,
      partitionBy: /\.partition_by\(\w+\)/g,
      window: /\.window\([^)]+\)/g,
      aggregate: /\.aggregate\(\s*\n([^)]+)\)/g,
      where: /\.where\([^)]+\)/g,
      emit: /\.emit\(\s*\n([^)]+)\)/g
    };

    // Verify patterns exist in example
    for (const [name, regex] of Object.entries(patterns)) {
      const matches = hvacExample.match(regex);
      console.log(`${name}: ${matches?.length || 0} matches`);
      expect(matches?.length).toBeGreaterThan(0);
    }

    // Generate similar flow and verify same patterns work
    const flow: FlowGraph = {
      nodes: [
        {
          id: 'e1',
          type: 'event',
          label: 'TestEvent',
          config: {
            fields: [
              { name: 'id', type: 'str' },
              { name: 'value', type: 'float' },
              { name: 'ts', type: 'int' }
            ]
          }
        },
        {
          id: 's1',
          type: 'stream',
          label: 'TestStream',
          config: { isBase: true, source: 'TestEvent' }
        },
        {
          id: 's2',
          type: 'stream',
          label: 'AggregatedStream',
          config: {
            source: 'TestStream',
            partitionBy: 'id',
            window: '5m',
            aggregate: {
              id: 'last(id)',
              avg_value: 'avg(value)',
              count: 'count()'
            },
            emit: {
              result: 'avg_value'
            }
          }
        }
      ],
      connections: []
    };

    const vpl = generateVPL(flow);
    
    // Verify generated VPL has same patterns
    for (const [name, regex] of Object.entries(patterns)) {
      if (['eventDecl', 'streamBase', 'streamDef', 'partitionBy', 'window', 'aggregate', 'emit'].includes(name)) {
        const matches = vpl.match(regex);
        console.log(`Generated ${name}: ${matches?.length || 0} matches`);
      }
    }

    const result = validateVPL(vpl);
    expect(result.valid).toBe(true);
  });
});
