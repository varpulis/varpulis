/**
 * Real VPL Execution Tests
 * 
 * Tests that actually execute VPL code with the varpulis CLI
 * and verify output. Uses the REAL VPL syntax from the project.
 */

import { expect, test } from '@playwright/test';
import { execSync, spawnSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

const TEST_DIR = path.join(__dirname, '..', 'test-output');
const PROJECT_ROOT = path.join(__dirname, '..', '..', '..');
const CLI_PATH = path.join(PROJECT_ROOT, 'target', 'release', 'varpulis');

// Check if CLI is available
function cliAvailable(): boolean {
  try {
    const result = spawnSync(CLI_PATH, ['--help'], { timeout: 5000 });
    return result.status === 0;
  } catch {
    return false;
  }
}

test.beforeAll(async () => {
  if (!fs.existsSync(TEST_DIR)) {
    fs.mkdirSync(TEST_DIR, { recursive: true });
  }
});

test.describe('Real VPL Execution', () => {
  
  test('Check CLI availability', async () => {
    const available = cliAvailable();
    console.log(`CLI available: ${available}`);
    console.log(`CLI path: ${CLI_PATH}`);
    
    if (!available) {
      console.log('Building CLI...');
      try {
        execSync('cargo build --release -p varpulis-cli', { 
          cwd: PROJECT_ROOT, 
          timeout: 300000,
          stdio: 'inherit'
        });
      } catch (e) {
        console.log('Failed to build CLI:', e);
      }
    }
    
    expect(cliAvailable()).toBe(true);
  });

  test('Execute temperature monitoring VPL', async () => {
    test.skip(!cliAvailable(), 'CLI not available');
    
    // Create VPL file with REAL syntax
    const vplContent = `# Temperature Monitoring Test
# Generated by E2E test

# Event definition
event TempReading:
    sensor_id: str
    value: float
    ts: int

# Stream: Filter high temperatures
stream HighTemp = TempReading as t
    .print("Reading:", sensor_id, "=", value, "Â°C")
    .where(value > 30.0)
    .print("ðŸ”¥ HIGH TEMP:", sensor_id, "=", value)
    .emit(
        alert_type: "high_temperature",
        sensor_id: t.sensor_id,
        temperature: t.value
    )

# Stream: Calculate average per sensor (1 minute window)
stream TempAverage = TempReading
    .window(1m)
    .partition_by(sensor_id)
    .aggregate(
        avg_temp: avg(value),
        max_temp: max(value),
        min_temp: min(value),
        reading_count: count(sensor_id)
    )
    .print("ðŸ“Š Sensor", sensor_id, "avg:", avg_temp)
    .emit(
        report_type: "sensor_summary",
        sensor_id: sensor_id,
        avg_temp: avg_temp,
        max_temp: max_temp,
        min_temp: min_temp,
        count: reading_count
    )
`;

    const vplPath = path.join(TEST_DIR, 'temp-monitor.vpl');
    fs.writeFileSync(vplPath, vplContent);

    // Create event file with REAL syntax
    const evtContent = `# Temperature test events
@0s TempReading { sensor_id: "S1", value: 25.0, ts: 1000 }
@1s TempReading { sensor_id: "S2", value: 28.0, ts: 1001 }
@2s TempReading { sensor_id: "S1", value: 32.0, ts: 1002 }
@3s TempReading { sensor_id: "S2", value: 35.0, ts: 1003 }
@4s TempReading { sensor_id: "S1", value: 29.0, ts: 1004 }
@5s TempReading { sensor_id: "S3", value: 40.0, ts: 1005 }
@10s TempReading { sensor_id: "S1", value: 26.0, ts: 1010 }
@11s TempReading { sensor_id: "S2", value: 31.0, ts: 1011 }
`;

    const evtPath = path.join(TEST_DIR, 'temp-events.evt');
    fs.writeFileSync(evtPath, evtContent);

    // Execute with CLI
    const result = spawnSync(CLI_PATH, [
      'simulate',
      '--program', vplPath,
      '--events', evtPath,
      '--immediate',
      '--verbose'
    ], {
      cwd: TEST_DIR,
      timeout: 30000,
      encoding: 'utf-8'
    });

    console.log('=== CLI OUTPUT ===');
    console.log(result.stdout);
    if (result.stderr) {
      console.log('=== CLI STDERR ===');
      console.log(result.stderr);
    }
    console.log(`Exit code: ${result.status}`);

    // Verify execution succeeded
    expect(result.status).toBe(0);
    
    // Verify events were processed
    expect(result.stdout).toContain('Events processed:');
    expect(result.stdout).toMatch(/Events processed:\s+8/);
  });

  test('Execute sequence pattern detection', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    const vplContent = `# Sequence Pattern Test
# Detects A -> B sequences within time window

event EventA:
    id: str
    value: int
    ts: int

event EventB:
    id: str
    result: str
    ts: int

# Detect sequence: EventA followed by EventB with same id
stream ABSequence = EventA as a
    -> EventB where id == a.id as b
    .within(5m)
    .print("âœ… Sequence detected:", a.id, "->", b.result)
    .emit(
        pattern: "A_then_B",
        entity_id: a.id,
        a_value: a.value,
        b_result: b.result
    )
`;

    const vplPath = path.join(TEST_DIR, 'sequence-test.vpl');
    fs.writeFileSync(vplPath, vplContent);

    const evtContent = `# Sequence test events
@0s EventA { id: "X1", value: 100, ts: 1000 }
@1s EventA { id: "X2", value: 200, ts: 1001 }
@2s EventB { id: "X1", result: "success", ts: 1002 }
@3s EventA { id: "X3", value: 300, ts: 1003 }
@4s EventB { id: "X2", result: "failure", ts: 1004 }
@10s EventB { id: "X3", result: "pending", ts: 1010 }
`;

    const evtPath = path.join(TEST_DIR, 'sequence-events.evt');
    fs.writeFileSync(evtPath, evtContent);

    const result = spawnSync(CLI_PATH, [
      'simulate',
      '--program', vplPath,
      '--events', evtPath,
      '--immediate',
      '--verbose'
    ], {
      cwd: TEST_DIR,
      timeout: 30000,
      encoding: 'utf-8'
    });

    console.log('=== SEQUENCE TEST OUTPUT ===');
    console.log(result.stdout);
    console.log(`Exit code: ${result.status}`);

    expect(result.status).toBe(0);
    expect(result.stdout).toContain('Events processed:');
  });

  test('Execute existing electrical consumption scenario', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    const vplPath = path.join(PROJECT_ROOT, 'tests', 'scenarios', 'electrical_consumption.vpl');
    const evtPath = path.join(PROJECT_ROOT, 'tests', 'scenarios', 'electrical_consumption.evt');

    // Verify files exist
    expect(fs.existsSync(vplPath)).toBe(true);
    expect(fs.existsSync(evtPath)).toBe(true);

    const result = spawnSync(CLI_PATH, [
      'simulate',
      '--program', vplPath,
      '--events', evtPath,
      '--immediate',
      '--verbose'
    ], {
      cwd: PROJECT_ROOT,
      timeout: 30000,
      encoding: 'utf-8'
    });

    console.log('=== ELECTRICAL CONSUMPTION OUTPUT ===');
    console.log(result.stdout);
    console.log(`Exit code: ${result.status}`);

    expect(result.status).toBe(0);
    expect(result.stdout).toContain('Simulation Complete');
    expect(result.stdout).toContain('Events processed: 19');
  });

  test('Validate VPL syntax with check command', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    const vplContent = `# Syntax check test
event TestEvent:
    field1: str
    field2: int

stream TestStream = TestEvent
    .where(field2 > 0)
    .emit(result: field1)
`;

    const vplPath = path.join(TEST_DIR, 'syntax-check.vpl');
    fs.writeFileSync(vplPath, vplContent);

    const result = spawnSync(CLI_PATH, ['check', vplPath], {
      cwd: TEST_DIR,
      timeout: 10000,
      encoding: 'utf-8'
    });

    console.log('=== SYNTAX CHECK OUTPUT ===');
    console.log(result.stdout);
    console.log(result.stderr);
    console.log(`Exit code: ${result.status}`);

    expect(result.status).toBe(0);
  });

  test('Parse VPL and show AST', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    const vplPath = path.join(PROJECT_ROOT, 'tests', 'scenarios', 'electrical_consumption.vpl');

    const result = spawnSync(CLI_PATH, ['parse', vplPath], {
      cwd: PROJECT_ROOT,
      timeout: 10000,
      encoding: 'utf-8'
    });

    console.log('=== PARSE OUTPUT (first 2000 chars) ===');
    console.log(result.stdout.substring(0, 2000));
    console.log(`Exit code: ${result.status}`);

    expect(result.status).toBe(0);
    // Should contain AST elements
    expect(result.stdout.length).toBeGreaterThan(100);
  });

  test('Flow to VPL conversion produces valid code', async () => {
    test.skip(!cliAvailable(), 'CLI not available');

    // Simulate what the flow editor would generate
    // This tests the VPL generation that will be in the editor
    
    const flow = {
      nodes: [
        { id: 'n1', type: 'event', label: 'SensorData', config: { fields: 'device_id: str\ntemperature: float\nhumidity: float\nts: int' }},
        { id: 'n2', type: 'stream', label: 'HighHumidity', config: { 
          source: 'SensorData',
          filter: 'humidity > 80.0',
          emit: 'alert_type: "high_humidity"\ndevice_id: device_id\nhumidity: humidity'
        }},
      ]
    };

    // Generate VPL from flow (proper syntax)
    const vpl = flowToVPL(flow);
    
    const vplPath = path.join(TEST_DIR, 'flow-generated.vpl');
    fs.writeFileSync(vplPath, vpl);
    
    console.log('=== GENERATED VPL ===');
    console.log(vpl);

    // Validate with CLI
    const result = spawnSync(CLI_PATH, ['check', vplPath], {
      cwd: TEST_DIR,
      timeout: 10000,
      encoding: 'utf-8'
    });

    console.log(`Check exit code: ${result.status}`);
    if (result.stderr) console.log('Stderr:', result.stderr);

    expect(result.status).toBe(0);
  });
});

// Helper: Convert flow graph to REAL VPL syntax
function flowToVPL(flow: { nodes: any[] }): string {
  let vpl = `# Generated by Varpulis Flow Editor\n# ${new Date().toISOString()}\n\n`;

  const events = flow.nodes.filter(n => n.type === 'event');
  const streams = flow.nodes.filter(n => n.type === 'stream');

  // Generate events
  for (const evt of events) {
    const name = evt.label;
    vpl += `event ${name}:\n`;
    
    const fields = evt.config?.fields || '';
    for (const line of fields.split('\n')) {
      if (line.trim()) {
        vpl += `    ${line.trim()}\n`;
      }
    }
    vpl += '\n';
  }

  // Generate streams
  for (const stream of streams) {
    const name = stream.label;
    const source = stream.config?.source || 'Event';
    const filter = stream.config?.filter;
    const emit = stream.config?.emit;

    vpl += `stream ${name} = ${source}\n`;
    
    if (filter) {
      vpl += `    .where(${filter})\n`;
    }
    
    if (emit) {
      vpl += `    .emit(\n`;
      const lines = emit.split('\n').filter((l: string) => l.trim());
      lines.forEach((line: string, idx: number) => {
        const comma = idx < lines.length - 1 ? ',' : '';
        vpl += `        ${line.trim()}${comma}\n`;
      });
      vpl += `    )\n`;
    }
    vpl += '\n';
  }

  return vpl;
}
